#!/usr/bin/env bb
(ns tmuxb.lib.send
  "EDN-based DSL for sending keys, text, and mouse events to tmux panes.

   Any user-visible behavior changes must be documented in:
   doc/send-keys-dsl.md"
  (:require [clojure.edn :as edn]
            [clojure.string :as str])
  (:import [java.io PushbackReader]))

(def named-keys
  "Map of DSL key names to tmux key names."
  {:Enter     "Enter"
   :Return    "Enter"
   :Escape    "Escape"
   :Esc       "Escape"
   :Tab       "Tab"
   :Space     "Space"
   :Backspace "BSpace"
   :BS        "BSpace"
   :Delete    "DC"
   :Del       "DC"
   :Insert    "IC"
   :Ins       "IC"
   :Home      "Home"
   :End       "End"
   :PageUp    "PageUp"
   :PgUp      "PageUp"
   :PageDown  "PageDown"
   :PgDn      "PageDown"
   :Up        "Up"
   :Down      "Down"
   :Left      "Left"
   :Right     "Right"
   :F1        "F1"
   :F2        "F2"
   :F3        "F3"
   :F4        "F4"
   :F5        "F5"
   :F6        "F6"
   :F7        "F7"
   :F8        "F8"
   :F9        "F9"
   :F10       "F10"
   :F11       "F11"
   :F12       "F12"
   :Control   "Control"
   :Shift     "Shift"
   :Alt       "Alt"
   :Meta      "Meta"
   :Super     "Super"
   :Hyper     "Hyper"})

(def modifier-prefixes
  "Modifier prefix patterns.
   tmux send-keys only supports C-, M-, S-.
   Super- and Hyper- require hex mode (Kitty protocol)."
  [["C-"     {:tmux "C-" :kitty-bit 4}]
   ["M-"     {:tmux "M-" :kitty-bit 2}]
   ["S-"     {:tmux "S-" :kitty-bit 1}]
   ["Super-" {:tmux nil :kitty-bit 8}]
   ["Hyper-" {:tmux nil :kitty-bit 16}]])

(defn char->codepoint
  "Get Unicode codepoint for a character or key name."
  [key-str]
  (cond
    (= 1 (count key-str)) (int (first key-str))
    (= "Enter" key-str)   13
    (= "Escape" key-str)  27
    (= "Tab" key-str)     9
    (= "Space" key-str)   32
    (= "BSpace" key-str)  127
    :else                 (int (first key-str))))

(defn kitty-key-event
  "Generate Kitty keyboard protocol sequence. Returns hex string.
   key-str   - the key name (e.g., \"a\", \"Enter\")
   modifiers - modifier bits + 1 (Kitty format)
   event     - 1 for press, 3 for release"
  [key-str modifiers event]
  (let [codepoint (char->codepoint key-str)
        seq       (format "\u001b[%d;%d:%du" codepoint modifiers event)]
    (str/join " " (map #(format "%02x" (int %)) seq))))

(defn parse-key-keyword
  "Parse a key keyword like :C-x or :Enter.
   Returns {:tmux \"C-x\"} for tmux-compatible keys,
   or {:hex \"...\"} when hex mode is required (Super/Hyper modifiers)."
  [kw]
  (let [s (name kw)]
    (loop [remaining   s
           tmux-prefix ""
           kitty-bits  0
           needs-hex?  false]
      (if-let [[dsl-prefix {:keys [tmux kitty-bit]}]
               (first (filter #(str/starts-with? remaining (first %))
                              modifier-prefixes))]
        (recur (subs remaining (count dsl-prefix))
               (if tmux (str tmux-prefix tmux) tmux-prefix)
               (bit-or kitty-bits kitty-bit)
               (or needs-hex? (nil? tmux)))
        (let [key-kw   (keyword remaining)
              key-name (or (get named-keys key-kw) remaining)]
          (if needs-hex?
            {:hex (kitty-key-event key-name (inc kitty-bits) 1)}
            {:tmux (str tmux-prefix key-name)}))))))

(def mouse-button-codes
  {:left   0
   :middle 1
   :right  2})

(def mouse-modifier-codes
  {:S     4
   :Shift 4
   :M     8
   :Meta  8
   :Alt   8
   :C     16
   :Ctrl  16})

(defn encode-mouse-button
  "Encode mouse button with modifiers. Returns button code."
  [button modifiers]
  (let [base     (get mouse-button-codes button 0)
        mod-bits (reduce + 0 (map #(get mouse-modifier-codes % 0) modifiers))]
    (+ base mod-bits)))

(defn sgr-mouse-press
  "Generate SGR mouse press sequence. Returns hex string."
  [x y button modifiers]
  (let [code (encode-mouse-button button modifiers)
        seq  (format "\u001b[<%d;%d;%dM" code x y)]
    (str/join " " (map #(format "%02x" (int %)) seq))))

(defn sgr-mouse-release
  "Generate SGR mouse release sequence. Returns hex string."
  [x y button modifiers]
  (let [code (encode-mouse-button button modifiers)
        seq  (format "\u001b[<%d;%d;%dm" code x y)]
    (str/join " " (map #(format "%02x" (int %)) seq))))

(defn sgr-scroll
  "Generate SGR scroll sequence. Returns hex string.
   direction is :up or :down"
  [x y direction modifiers]
  (let [base     (if (= direction :up) 64 65)
        mod-bits (reduce + 0 (map #(get mouse-modifier-codes % 0) modifiers))
        code     (+ base mod-bits)
        seq      (format "\u001b[<%d;%d;%dM" code x y)]
    (str/join " " (map #(format "%02x" (int %)) seq))))

(defn parse-kitty-key
  "Parse key keyword into [codepoint modifier-bits]."
  [kw]
  (let [s (name kw)]
    (loop [remaining s
           mod-bits  0]
      (cond
        (str/starts-with? remaining "C-")
        (recur (subs remaining 2) (bit-or mod-bits 4))

        (str/starts-with? remaining "M-")
        (recur (subs remaining 2) (bit-or mod-bits 2))

        (str/starts-with? remaining "S-")
        (recur (subs remaining 2) (bit-or mod-bits 1))

        (str/starts-with? remaining "Super-")
        (recur (subs remaining 6) (bit-or mod-bits 8))

        (str/starts-with? remaining "Hyper-")
        (recur (subs remaining 6) (bit-or mod-bits 16))

        :else
        (let [key-name  (or (get named-keys (keyword remaining)) remaining)
              codepoint (char->codepoint key-name)]
          [codepoint (inc mod-bits)])))))

(defn kitty-key-press
  "Generate Kitty keyboard protocol press sequence. Returns hex string."
  [key-kw]
  (let [[codepoint modifiers] (parse-kitty-key key-kw)
        seq                   (format "\u001b[%d;%d:1u" codepoint modifiers)]
    (str/join " " (map #(format "%02x" (int %)) seq))))

(defn kitty-key-release
  "Generate Kitty keyboard protocol release sequence. Returns hex string."
  [key-kw]
  (let [[codepoint modifiers] (parse-kitty-key key-kw)
        seq                   (format "\u001b[%d;%d:3u" codepoint modifiers)]
    (str/join " " (map #(format "%02x" (int %)) seq))))

(defn parse-raw-string
  "Parse raw string with \\e and \\xNN escapes. Returns hex string."
  [s]
  (let [sb  (StringBuilder.)
        len (count s)]
    (loop [i 0]
      (if (>= i len)
        (str/join " " (map #(format "%02x" (int %)) (str sb)))
        (let [c (nth s i)]
          (if (and (= c \\) (< (inc i) len))
            (let [next-c (nth s (inc i))]
              (cond
                (= next-c \e)
                (do (.append sb \u001b)
                    (recur (+ i 2)))

                (= next-c \x)
                (if (< (+ i 3) len)
                  (let [hex-str  (subs s (+ i 2) (+ i 4))
                        byte-val (Integer/parseInt hex-str 16)]
                    (.append sb (char byte-val))
                    (recur (+ i 4)))
                  (do (.append sb c)
                      (recur (inc i))))

                (= next-c \n) (do (.append sb \newline) (recur (+ i 2)))
                (= next-c \t) (do (.append sb \tab) (recur (+ i 2)))
                (= next-c \r) (do (.append sb \return) (recur (+ i 2)))
                (= next-c \\) (do (.append sb \\) (recur (+ i 2)))
                (= next-c \") (do (.append sb \") (recur (+ i 2)))

                :else
                (do (.append sb c)
                    (recur (inc i)))))
            (do (.append sb c)
                (recur (inc i)))))))))

(defn parse-raw-hex
  "Parse hex string like '1b 5b 39'. Returns normalized hex string."
  [s]
  (str/replace s #"\s+" " "))

(defn action-type
  "Determine the type of an action for dispatch."
  [action]
  (cond
    (string? action)  :string
    (keyword? action) :keyword
    (vector? action)  (let [head (first action)]
                        (cond
                          (string? head)  :string-repeat
                          (keyword? head) head
                          :else           :unknown))
    :else             :unknown))

(defmulti execute-action
  "Execute a single action. Dispatches on action type."
  (fn [_send-fn _send-hex-fn action] (action-type action)))

(defmethod execute-action :string
  [send-fn _send-hex-fn s]
  (send-fn s))

(defmethod execute-action :keyword
  [send-fn send-hex-fn kw]
  (let [{:keys [tmux hex]} (parse-key-keyword kw)]
    (if hex
      (send-hex-fn hex)
      (send-fn tmux))))

(defmethod execute-action :string-repeat
  [send-fn _send-hex-fn [s count & {:keys [delay]}]]
  (dotimes [i count]
    (send-fn s)
    (when (and delay (< i (dec count)))
      (Thread/sleep delay))))

(defmethod execute-action :Sleep
  [_send-fn _send-hex-fn [_ ms]]
  (Thread/sleep ms))

(defmethod execute-action :Click
  [_send-fn send-hex-fn [_ x y & modifiers]]
  (send-hex-fn (sgr-mouse-press x y :left modifiers))
  (send-hex-fn (sgr-mouse-release x y :left modifiers)))

(defmethod execute-action :RClick
  [_send-fn send-hex-fn [_ x y & modifiers]]
  (send-hex-fn (sgr-mouse-press x y :right modifiers))
  (send-hex-fn (sgr-mouse-release x y :right modifiers)))

(defmethod execute-action :MClick
  [_send-fn send-hex-fn [_ x y & modifiers]]
  (send-hex-fn (sgr-mouse-press x y :middle modifiers))
  (send-hex-fn (sgr-mouse-release x y :middle modifiers)))

(defmethod execute-action :Click+
  [_send-fn send-hex-fn [_ x y & modifiers]]
  (send-hex-fn (sgr-mouse-press x y :left modifiers)))

(defmethod execute-action :Click-
  [_send-fn send-hex-fn [_ x y & modifiers]]
  (send-hex-fn (sgr-mouse-release x y :left modifiers)))

(defmethod execute-action :Move
  [_send-fn send-hex-fn [_ x y]]
  (let [seq (format "\u001b[<%d;%d;%dM" 35 x y)
        hex (str/join " " (map #(format "%02x" (int %)) seq))]
    (send-hex-fn hex)))

(defmethod execute-action :ScrollUp
  [_send-fn send-hex-fn [_ x y & args]]
  (let [[count-or-kw & rest-args] args
        [cnt delay-val]           (if (number? count-or-kw)
                                    [count-or-kw (second rest-args)]
                                    [1 nil])]
    (dotimes [i cnt]
      (send-hex-fn (sgr-scroll x y :up []))
      (when (and delay-val (< i (dec cnt)))
        (Thread/sleep delay-val)))))

(defmethod execute-action :ScrollDown
  [_send-fn send-hex-fn [_ x y & args]]
  (let [[count-or-kw & rest-args] args
        [cnt delay-val]           (if (number? count-or-kw)
                                    [count-or-kw (second rest-args)]
                                    [1 nil])]
    (dotimes [i cnt]
      (send-hex-fn (sgr-scroll x y :down []))
      (when (and delay-val (< i (dec cnt)))
        (Thread/sleep delay-val)))))

(defmethod execute-action :Raw
  [_send-fn send-hex-fn [_ s]]
  (send-hex-fn (parse-raw-string s)))

(defmethod execute-action :RawHex
  [_send-fn send-hex-fn [_ s]]
  (send-hex-fn (parse-raw-hex s)))

(defmethod execute-action :default
  [send-fn send-hex-fn action]
  (if (vector? action)
    (let [[key-kw & rest-args] action]
      (cond
        (and (keyword? key-kw)
             (= 1 (count rest-args))
             (#{:down :up :press :release} (first rest-args)))
        (let [direction (first rest-args)]
          (if (#{:down :press} direction)
            (send-hex-fn (kitty-key-press key-kw))
            (send-hex-fn (kitty-key-release key-kw))))

        (and (keyword? key-kw) (number? (first rest-args)))
        (let [[cnt & {:keys [delay]}] rest-args
              {:keys [tmux hex]}      (parse-key-keyword key-kw)]
          (dotimes [i cnt]
            (if hex
              (send-hex-fn hex)
              (send-fn tmux))
            (when (and delay (< i (dec cnt)))
              (Thread/sleep delay))))

        :else
        (throw (ex-info "Unknown action" {:action action}))))
    (throw (ex-info "Unknown action type. Strings must be quoted in EDN format."
                    {:action action :type (type action)}))))

(def default-delay
  "Default delay in milliseconds between actions (simulates fast human typing)."
  30)

(defn execute
  "Execute a sequence of actions.

   send-fn     - function to send regular keys: (send-fn key-string)
   send-hex-fn - function to send hex bytes: (send-hex-fn hex-string)
   actions     - sequence of actions (strings, keywords, vectors)
   delay-ms    - delay in milliseconds between actions (default 30)"
  ([send-fn send-hex-fn actions]
   (execute send-fn send-hex-fn actions default-delay))
  ([send-fn send-hex-fn actions delay-ms]
   (let [action-vec (vec actions)
         last-idx   (dec (count action-vec))]
     (doseq [[idx action] (map-indexed vector action-vec)]
       (execute-action send-fn send-hex-fn action)
       (when (and (pos? delay-ms) (< idx last-idx))
         (Thread/sleep delay-ms))))))

(defn execute-stream
  "Execute actions from an EDN stream (e.g., stdin).
   Reads and executes one action at a time.

   send-fn     - function to send regular keys
   send-hex-fn - function to send hex bytes
   reader      - a PushbackReader
   delay-ms    - delay in milliseconds between actions (default 30)"
  ([send-fn send-hex-fn reader]
   (execute-stream send-fn send-hex-fn reader default-delay))
  ([send-fn send-hex-fn reader delay-ms]
   (loop [first? true]
     (when-let [action (edn/read {:eof nil} reader)]
       (when (and (not first?) (pos? delay-ms))
         (Thread/sleep delay-ms))
       (execute-action send-fn send-hex-fn action)
       (recur false)))))

(defn execute-string
  "Execute actions from an EDN string."
  ([send-fn send-hex-fn s]
   (execute-string send-fn send-hex-fn s default-delay))
  ([send-fn send-hex-fn s delay-ms]
   (with-open [rdr (PushbackReader. (java.io.StringReader. s))]
     (execute-stream send-fn send-hex-fn rdr delay-ms))))

(defn run-send
  "Execute send actions with clean error handling.
   Takes edn-str (may be blank) and stdin-reader for fallback.
   Returns nil on success, exits with code 1 on error."
  ([send-fn send-hex-fn edn-str stdin-reader]
   (run-send send-fn send-hex-fn edn-str stdin-reader default-delay))
  ([send-fn send-hex-fn edn-str stdin-reader delay-ms]
   (try
     (if (str/blank? edn-str)
       (with-open [rdr (PushbackReader. stdin-reader)]
         (execute-stream send-fn send-hex-fn rdr delay-ms))
       (execute-string send-fn send-hex-fn edn-str delay-ms))
     (catch clojure.lang.ExceptionInfo e
       (binding [*out* *err*]
         (println (str "Error: " (ex-message e)))
         (when-let [action (:action (ex-data e))]
           (println (str "  Got: " (pr-str action) " (type: " (type action) ")")))
         (println "  Hint: Strings must be quoted in EDN format, e.g., '\"echo hello\"'"))
       (System/exit 1)))))

(comment
  (defn mock-send [s] (println "send:" s))
  (defn mock-hex [s] (println "hex:" s))

  (execute mock-send mock-hex ["hello" :Enter])
  (execute mock-send mock-hex [[:Click 50 40 :C]])
  (execute mock-send mock-hex [[:Sleep 100] "done"])
  (execute mock-send mock-hex [[:Enter 5 :delay 100]])
  (execute mock-send mock-hex [[:a :down] [:Sleep 500] [:a :up]])
  (execute mock-send mock-hex [[:Raw "\\e[97;1:1u"]])
  (execute mock-send mock-hex [:Super-l])

  (execute-string mock-send mock-hex "\"hello\" :Enter [:Sleep 100]"))

(ns tmuxb
  "tmux-buddy - tmux interface for Claude Code."
  (:require
   [babashka.cli :as cli]
   [babashka.fs :as fs]
   [babashka.process :as p]
   [cheshire.core :as json]
   [clojure.edn :as edn]
   [clojure.string :as str]
   [tmuxb.lib.send :as send]))

;;; ---------------------------------------------------------------------------
;;; ANSI Handling
;;; ---------------------------------------------------------------------------

(def ansi-pattern #"\x1b\[[0-9;]*m")

(defn strip-ansi
  "Remove all ANSI escape codes from text."
  [text]
  (str/replace text ansi-pattern ""))

(def style-codes
  "Regex patterns for detecting ANSI styles."
  {:inverse   #"\x1b\[7m"
   :bg-color  #"\x1b\[4[0-7]m"
   :bold      #"\x1b\[1m"
   :red       #"\x1b\[31m"
   :green     #"\x1b\[32m"
   :yellow    #"\x1b\[33m"
   :underline #"\x1b\[4m(?![0-7])"
   :reset     #"\x1b\[0?m"})

;;; ---------------------------------------------------------------------------
;;; Cursor Markers
;;; ---------------------------------------------------------------------------

(def cursor-left "᚛")
(def cursor-right "᚜")
(def cursor-placeholder-left "\u0000CURSOR_L\u0000")
(def cursor-placeholder-right "\u0000CURSOR_R\u0000")

(defn insert-cursor-marker
  "Insert visible cursor markers around the character at cursor position.
   Works on ANSI-stripped content where visual positions match character positions."
  [content cursor-x cursor-y]
  (let [lines (str/split-lines content)]
    (if (and (>= cursor-y 0) (< cursor-y (count lines)))
      (let [line     (nth lines cursor-y)
            new-line (if (< cursor-x (count line))
                       (str (subs line 0 cursor-x)
                            cursor-left
                            (subs line cursor-x (inc cursor-x))
                            cursor-right
                            (subs line (inc cursor-x)))
                       (str line cursor-left " " cursor-right))]
        (str/join "\n" (assoc (vec lines) cursor-y new-line)))
      content)))

(defn insert-cursor-placeholder
  "Insert placeholder markers at cursor position (for use before ANSI transformation)."
  [content cursor-x cursor-y]
  (let [lines (str/split-lines content)]
    (if (and (>= cursor-y 0) (< cursor-y (count lines)))
      (let [line       (nth lines cursor-y)
            clean-line (strip-ansi line)]
        (if (< cursor-x (count clean-line))
          ;; Find where cursor-x in clean line corresponds to in original line
          (loop [visual-pos 0
                 actual-pos 0]
            (if (or (>= visual-pos cursor-x) (>= actual-pos (count line)))
              (let [char-at-cursor (if (< actual-pos (count line))
                                     (subs line actual-pos (inc actual-pos))
                                     " ")
                    new-line       (str (subs line 0 actual-pos)
                                        cursor-placeholder-left
                                        char-at-cursor
                                        cursor-placeholder-right
                                        (subs line (min (inc actual-pos) (count line))))]
                (str/join "\n" (assoc (vec lines) cursor-y new-line)))
              (if (= (nth line actual-pos) \u001b)
                ;; Skip ANSI sequence
                (let [end (str/index-of line "m" actual-pos)]
                  (if end
                    (recur visual-pos (inc end))
                    (recur (inc visual-pos) (inc actual-pos))))
                (recur (inc visual-pos) (inc actual-pos)))))
          ;; Cursor past end of line
          (let [new-line (str line cursor-placeholder-left " " cursor-placeholder-right)]
            (str/join "\n" (assoc (vec lines) cursor-y new-line)))))
      content)))

(defn replace-cursor-placeholders
  "Replace cursor placeholders with actual Ogham markers."
  [content]
  (-> content
      (str/replace cursor-placeholder-left cursor-left)
      (str/replace cursor-placeholder-right cursor-right)))

;;; ---------------------------------------------------------------------------
;;; Style Detection and Transformation
;;; ---------------------------------------------------------------------------

(defn detect-line-style
  "Detect dominant style in a line. Returns style keyword or nil."
  [line]
  (cond
    (re-find (:inverse style-codes) line)  :inverse
    (re-find (:bg-color style-codes) line) :inverse  ; Treat bg color as selection
    (re-find (:red style-codes) line)      :red
    (re-find (:bold style-codes) line)     :bold
    :else nil))

(defn transform-lines-style
  "Transform content with line-prefix style markers."
  [content]
  (->> (str/split-lines content)
       (map (fn [line]
              (let [style      (detect-line-style line)
                    clean-line (strip-ansi line)]
                (case style
                  :inverse (str "> " clean-line)
                  :red     (str "! " clean-line)
                  :bold    (str "* " clean-line)
                  (str "  " clean-line)))))
       (str/join "\n")))

(defn transform-tags-style
  "Transform content with inline semantic tags."
  [content]
  (let [tag-map {:inverse "i" :bg-color "i" :bold      "b" :red "r"
                 :green   "g" :yellow   "y" :underline "u"}]
    (loop [i              0
           result         []
           current-styles #{}
           text           content]
      (if (>= i (count text))
        ;; Close any remaining open tags
        (apply str (concat result
                           (for [style current-styles
                                 :let  [tag (get tag-map style)]
                                 :when tag]
                             (str "[/" tag "]"))))
        (if (and (= (nth text i) \u001b)
                 (< (inc i) (count text))
                 (= (nth text (inc i)) \[))
          ;; ANSI escape sequence
          (let [end (str/index-of text "m" i)]
            (if end
              (let [seq (subs text i (inc end))]
                (cond
                  ;; Reset
                  (re-matches #"\x1b\[0?m" seq)
                  (let [close-tags (for [style current-styles
                                         :let  [tag (get tag-map style)]
                                         :when tag]
                                     (str "[/" tag "]"))]
                    (recur (inc end) (into result close-tags) #{} text))

                  ;; Default bg (49) resets selection
                  (re-matches #"\x1b\[49m" seq)
                  (if (contains? current-styles :bg-color)
                    (recur (inc end) (conj result "[/i]") (disj current-styles :bg-color) text)
                    (recur (inc end) result current-styles text))

                  ;; Check for style start
                  :else
                  (let [matched-style (first (for [[style-name pattern] style-codes
                                                   :when                (and (not= style-name :reset)
                                                                             (re-matches pattern seq))]
                                               style-name))]
                    (if (and matched-style (not (contains? current-styles matched-style)))
                      (let [tag (get tag-map matched-style)]
                        (if tag
                          (recur (inc end) (conj result (str "[" tag "]"))
                                 (conj current-styles matched-style) text)
                          (recur (inc end) result current-styles text)))
                      (recur (inc end) result current-styles text)))))
              (recur (inc i) (conj result (nth text i)) current-styles text)))
          ;; Regular character
          (recur (inc i) (conj result (nth text i)) current-styles text))))))

;;; ---------------------------------------------------------------------------
;;; Screen Hash Persistence
;;; ---------------------------------------------------------------------------

(defn md5-hash
  "Calculate MD5 hash of a string."
  [s]
  (let [md    (java.security.MessageDigest/getInstance "MD5")
        bytes (.digest md (.getBytes s "UTF-8"))]
    (apply str (map #(format "%02x" %) bytes))))

(defn cache-dir
  "Returns the XDG cache directory for tmux-buddy.
  Uses $XDG_CACHE_HOME if set, otherwise falls back to $HOME/.cache."
  []
  (let [xdg-cache (System/getenv "XDG_CACHE_HOME")
        base      (if (and xdg-cache (not (str/blank? xdg-cache)))
                    xdg-cache
                    (str (System/getenv "HOME") "/.cache"))]
    (fs/path base "tmux-buddy")))

(def hash-file (fs/path (cache-dir) "screen_hashes.edn"))

(defn load-screen-hashes
  "Load screen hashes from cache file."
  []
  (if (fs/exists? hash-file)
    (try
      (edn/read-string (slurp (str hash-file)))
      (catch Exception _ {}))
    {}))

(defn save-screen-hash
  "Save a screen hash to cache file."
  [key hash-val]
  (let [hashes (assoc (load-screen-hashes) key hash-val)]
    (fs/create-dirs (cache-dir))
    (spit (str hash-file) (pr-str hashes))))

;;; ---------------------------------------------------------------------------
;;; Session File Discovery
;;; ---------------------------------------------------------------------------

(defn find-session-file
  "Walk up from cwd looking for .tmuxb_session file.
  Returns the path if found, nil otherwise."
  []
  (loop [dir (fs/cwd)]
    (let [f (fs/path dir ".tmuxb_session")]
      (cond
        (fs/exists? f)           f
        (nil? (fs/parent dir))   nil
        :else                    (recur (fs/parent dir))))))

(defn read-session-file
  "Read and parse .tmuxb_session file, returns nil if not found or invalid.
  Expected format: {:session \"name\" :socket \"/path/to/socket\"}"
  []
  (when-let [f (find-session-file)]
    (try
      (edn/read-string (slurp (str f)))
      (catch Exception _ nil))))

(defn resolve-socket-path
  "Resolve socket path. Bare names become $XDG_RUNTIME_DIR/tmuxb/name or /tmp/tmuxb/name.
  Paths starting with /, ./, or ../ are used as-is."
  [socket]
  (when socket
    (if (or (str/starts-with? socket "/")
            (str/starts-with? socket "./")
            (str/starts-with? socket "../"))
      socket
      (let [runtime-dir (or (System/getenv "XDG_RUNTIME_DIR") "/tmp")
            dir         (fs/path runtime-dir "tmuxb")]
        (fs/create-dirs dir)
        (str (fs/path dir socket))))))

(defn write-session-file
  "Write .tmuxb_session file in cwd."
  [session socket]
  (let [content (cond-> {:session session}
                  socket (assoc :socket socket))]
    (spit ".tmuxb_session" (pr-str content))))

(defn delete-session-file-if-matches
  "Delete .tmuxb_session in cwd if it matches the given session/socket."
  [session socket]
  (when (fs/exists? ".tmuxb_session")
    (let [current (read-session-file)]
      (when (and (= (:session current) session)
                 (= (:socket current) socket))
        (fs/delete ".tmuxb_session")))))

(defn get-socket-path
  "Get the tmux server socket path by querying tmux."
  []
  (try
    (let [result (p/sh ["tmux" "display-message" "-p" "#{socket_path}"])]
      (if (zero? (:exit result))
        (str/trim (:out result))
        "default"))
    (catch Exception _ "default")))

(defn make-screen-hash-key
  "Create a cache key that includes socket hash to prevent collisions
  between different tmux servers."
  [session pane]
  (let [socket-hash (subs (md5-hash (get-socket-path)) 0 8)]
    (str socket-hash ":" session ":" (or pane ""))))

;;; ---------------------------------------------------------------------------
;;; tmux Format Generation
;;; ---------------------------------------------------------------------------

;; Define formats as EDN with type hints:
;;   :str  -> quoted string with escaped quotes: "#{s/"/\\":var}"
;;   :int  -> bare integer: #{var}
;;   :bool -> bare integer (0/1): #{var}

(def session-schema
  {:name     [:str "session_name"]
   :id       [:str "session_id"]
   :windows  [:int "session_windows"]
   :attached [:int "session_attached"]})

(def window-schema
  {:name   [:str "window_name"]
   :id     [:str "window_id"]
   :index  [:int "window_index"]
   :panes  [:int "window_panes"]
   :active [:int "window_active"]})

(def pane-schema
  {:id           [:str "pane_id"]
   :index        [:int "pane_index"]
   :window       [:str "window_name"]
   :window-index [:int "window_index"]
   :width        [:int "pane_width"]
   :height       [:int "pane_height"]
   :active       [:int "pane_active"]})

(defn schema->tmux-format
  "Convert an EDN schema to a tmux format string.

   Schema is a map where values are [type tmux-var] pairs:
   - [:str \"var\"]  -> quoted with escaped quotes
   - [:int \"var\"]  -> bare number
   - [:bool \"var\"] -> bare number (0/1)"
  [schema]
  (str "{"
       (->> schema
            (map (fn [[k [type var]]]
                   (let [placeholder (case type
                                       :str (str "\"#{s/\"/\\\\\":" var "}\"")
                                       :int (str "#{" var "}")
                                       :bool (str "#{" var "}"))]
                     (str k " " placeholder))))
            (str/join " "))
       "}"))

(def session-format (schema->tmux-format session-schema))
(def window-format (schema->tmux-format window-schema))
(def pane-format (schema->tmux-format pane-schema))

;;; ---------------------------------------------------------------------------
;;; tmux Wrapper Functions
;;; ---------------------------------------------------------------------------

(def ^:dynamic *socket*
  "Dynamic var for tmux socket path. When set, all tmux commands use -S flag."
  nil)

(defn tmux
  "Run tmux command, return stdout or throw on error.
  Uses *socket* if bound to specify the tmux server socket."
  [& args]
  (let [base   (if *socket* ["tmux" "-S" *socket*] ["tmux"])
        result (p/sh (into base args))]
    (if (zero? (:exit result))
      (:out result)
      (throw (ex-info (str "tmux error: " (:err result))
                      {:stderr (:err result) :args args})))))

(defn tmux-ok?
  "Run tmux command, return true if successful.
  Uses *socket* if bound to specify the tmux server socket."
  [& args]
  (let [base   (if *socket* ["tmux" "-S" *socket*] ["tmux"])
        result (p/sh (into base args))]
    (zero? (:exit result))))

(defn parse-edn-lines
  "Parse tmux EDN-formatted output into seq of maps."
  [output]
  (->> (str/split-lines output)
       (remove str/blank?)
       (map edn/read-string)))

(defn list-sessions*
  "List all tmux sessions."
  []
  (try
    (-> (tmux "list-sessions" "-F" session-format)
        parse-edn-lines)
    (catch Exception _ [])))

(defn find-session
  "Find a session by name."
  [name]
  (first (filter #(= (:name %) name) (list-sessions*))))

(defn list-windows*
  "List windows in a session."
  [session]
  (-> (tmux "list-windows" "-t" session "-F" window-format)
      parse-edn-lines))

(defn list-panes*
  "List panes in a session."
  [session & {:keys [window]}]
  (let [target (if window (str session ":" window) session)]
    (-> (tmux "list-panes" "-t" target "-F" pane-format)
        parse-edn-lines)))

(defn capture-pane*
  "Capture pane contents."
  [session & {:keys [pane start end escape-sequences]}]
  (let [target (if pane (str session ":" pane) session)
        args   (cond-> ["capture-pane" "-t" target "-p"]
                 escape-sequences (conj "-e")
                 start (conj "-S" (str start))
                 end (conj "-E" (str end)))]
    (apply tmux args)))

(defn get-cursor-pos
  "Get cursor position as [x y]."
  [session & {:keys [pane]}]
  (let [target (if pane (str session ":" pane) session)
        output (tmux "display-message" "-t" target "-p" "#{cursor_x} #{cursor_y}")
        [x y]  (str/split (str/trim output) #" ")]
    [(parse-long x) (parse-long y)]))

(defn send-keys*
  "Send keys to a pane."
  [session keys & {:keys [pane literal]}]
  (let [target (if pane (str session ":" pane) session)
        args   (cond-> ["send-keys" "-t" target]
                 literal (conj "-l"))]
    (apply tmux (conj args "--" keys))))

(defn send-keys-hex*
  "Send hex-encoded bytes to a pane via tmux send-keys -H."
  [session hex-string & {:keys [pane]}]
  (let [target (if pane (str session ":" pane) session)]
    (apply tmux "send-keys" "-t" target "-H" (str/split hex-string #" "))))

(defn new-session*
  "Create a new tmux session."
  [name & {:keys [window cmd width height]}]
  (let [args (cond-> ["new-session" "-d" "-s" name]
               window (conj "-n" window)
               width (conj "-x" (str width))
               height (conj "-y" (str height)))]
    (apply tmux args)
    (when cmd
      (send-keys* name cmd))))

(defn kill-session*
  "Kill a tmux session."
  [session]
  (tmux "kill-session" "-t" session))

;;; ---------------------------------------------------------------------------
;;; CLI Help and Error Handling
;;; ---------------------------------------------------------------------------

;; Forward declarations for cmd-help and error handling
(declare commands)
(declare commands-order)
(declare get-cmd-spec)
(declare add-help-to-spec)

(defn print-cmd-help
  "Print help for a specific command."
  [cmd-name usage desc spec]
  (println (str "Usage: tmuxb " cmd-name " " usage))
  (println)
  (println desc)
  (when (seq spec)
    (println)
    (println "Options:")
    (println (cli/format-opts {:spec spec}))))

(defn exit-with-error
  "Print error message, show command help, and exit."
  [cmd-name message]
  (binding [*out* *err*]
    (println (str "Error: " message))
    (println)
    (when-let [{:keys [usage desc spec]} (get-cmd-spec cmd-name)]
      (print-cmd-help cmd-name usage desc (add-help-to-spec spec))))
  (System/exit 1))

;;; ---------------------------------------------------------------------------
;;; CLI Command Implementations
;;; ---------------------------------------------------------------------------

(defn cmd-list
  "List all tmux sessions."
  [{:keys [opts]}]
  (let [sessions (list-sessions*)]
    (cond
      (:json opts) (println (json/generate-string sessions {:pretty true}))
      (:edn opts)  (prn sessions)
      :else        (if (empty? sessions)
                     (println "No tmux sessions found")
                     (doseq [s sessions]
                       (let [attached (if (= (:attached s) 1) "*" "")]
                         (println (str (:name s) attached " (" (:windows s) " windows)"))))))))

(defn cmd-windows
  "List windows in a session."
  [{:keys [opts]}]
  (let [{:keys [session json edn]} opts]
    (when-not session
      (exit-with-error "windows" "session name required"))
    (when-not (find-session session)
      (binding [*out* *err*] (println (str "Session '" session "' not found")))
      (System/exit 1))
    (let [windows (list-windows* session)]
      (cond
        json (println (json/generate-string windows {:pretty true}))
        edn  (prn windows)
        :else (doseq [w windows]
                (let [active (if (= (:active w) 1) "*" "")]
                  (println (str (:index w) ": " (:name w) active " (" (:panes w) " panes)"))))))))

(defn cmd-panes
  "List panes in a session/window."
  [{:keys [opts]}]
  (let [{:keys [session window json edn]} opts]
    (when-not session
      (exit-with-error "panes" "session name required"))
    (when-not (find-session session)
      (binding [*out* *err*] (println (str "Session '" session "' not found")))
      (System/exit 1))
    (let [panes (list-panes* session :window window)]
      (cond
        json  (println (json/generate-string panes {:pretty true}))
        edn   (prn panes)
        :else (doseq [p panes]
                (let [active (if (= (:active p) 1) "*" "")]
                  (println (str (:id p) active " [" (:window p) ":" (:index p) "] "
                                (:width p) "x" (:height p)))))))))

(defn cmd-capture
  "Capture pane contents."
  [{:keys [opts]}]
  (let [{:keys [session pane lines if-changed history raw style]
         :or   {lines 50 style "none"}}                          opts]
    (when-not session
      (exit-with-error "capture" "session name required"))
    (when-not (find-session session)
      (binding [*out* *err*] (println (str "Session '" session "' not found")))
      (System/exit 1))

    (let [need-ansi (contains? #{"lines" "tags" "ansi"} style)
          content   (if history
                      (capture-pane* session :pane pane
                                     :start (str "-" lines) :end "-0"
                                     :escape-sequences need-ansi)
                      (capture-pane* session :pane pane
                                     :start 0 :end "-"
                                     :escape-sequences need-ansi))]
      ;; Check if changed
      (when if-changed
        (let [content-hash (md5-hash content)
              pane-key     (make-screen-hash-key session pane)
              hashes       (load-screen-hashes)]
          (if (= (get hashes pane-key) content-hash)
            (do (println "[no change]")
                (System/exit 0))
            (save-screen-hash pane-key content-hash))))

      (let [[cursor-x cursor-y] (get-cursor-pos session :pane pane)
            result              (case style
                                  "lines"
                                  (let [transformed (transform-lines-style content)]
                                    (if raw
                                      transformed
                                      (insert-cursor-marker transformed (+ cursor-x 2) cursor-y)))

                                  "tags"
                                  (let [with-placeholder (if raw
                                                           content
                                                           (insert-cursor-placeholder content cursor-x cursor-y))
                                        transformed      (transform-tags-style with-placeholder)]
                                    (if raw
                                      transformed
                                      (replace-cursor-placeholders transformed)))

                                  "ansi"
                                  (if raw
                                    content
                                    (-> content
                                        strip-ansi
                                        (insert-cursor-marker cursor-x cursor-y)))

                     ;; "none" (default)
                                  (let [stripped (if need-ansi (strip-ansi content) content)]
                                    (if raw
                                      stripped
                                      (insert-cursor-marker stripped cursor-x cursor-y))))]
        (println result)))))

(defn cmd-watch
  "Watch pane for changes, outputting only when content changes."
  [{:keys [opts]}]
  (let [{:keys [session pane interval timeout until]
         :or   {interval 0.5 timeout 30.0}}          opts]
    (when-not session
      (exit-with-error "watch" "session name required"))
    (when-not (find-session session)
      (binding [*out* *err*] (println (str "Session '" session "' not found")))
      (System/exit 1))

    (let [start-time (System/currentTimeMillis)]
      (loop [last-hash ""]
        (let [elapsed (/ (- (System/currentTimeMillis) start-time) 1000.0)]
          (if (>= elapsed timeout)
            (binding [*out* *err*]
              (println (str "[timeout after " timeout "s]")))
            (let [content      (capture-pane* session :pane pane :start 0 :end "-")
                  content-hash (md5-hash content)]
              (when (not= content-hash last-hash)
                (println (str "--- [" (format "%.1f" elapsed) "s] ---"))
                (println content)
                (let [[x y] (get-cursor-pos session :pane pane)]
                  (println (str "[cursor: " x "," y "]")))
                (when (and until (str/includes? content until))
                  (binding [*out* *err*]
                    (println (str "[found '" until "']")))
                  (System/exit 0)))
              (Thread/sleep (long (* interval 1000)))
              (recur content-hash))))))))

(defn cmd-send
  "Send keys to a pane using EDN DSL.

   Reads from stdin if no EDN arguments provided.
   See doc/send-keys-dsl.md for DSL specification."
  [{:keys [opts args]}]
  (let [{:keys [session pane delay]} opts
        edn-str                      (str/join " " (or args []))]
    (when-not session
      (exit-with-error "send" "session name required"))
    (when-not (find-session session)
      (binding [*out* *err*] (println (str "Session '" session "' not found")))
      (System/exit 1))

    (let [send-fn     #(send-keys* session % :pane pane)
          send-hex-fn #(send-keys-hex* session % :pane pane)]
      (send/run-send send-fn send-hex-fn edn-str *in* delay))))

(defn cmd-mouse
  "Send mouse click to pane at x,y coordinates."
  [{:keys [opts]}]
  (let [{:keys [session x y pane click double]
         :or   {click "left"}}                 opts]
    (when-not session
      (exit-with-error "mouse" "session name required"))
    (when-not (and x y)
      (exit-with-error "mouse" "x and y coordinates required"))
    (when-not (find-session session)
      (binding [*out* *err*] (println (str "Session '" session "' not found")))
      (System/exit 1))

    (let [button-map    {"left" 0 "middle" 1 "right" 2}
          button        (get button-map click 0)
          cb            (char (+ button 32))
          cx            (char (+ x 33))
          cy            (char (+ y 33))
          mouse-press   (str "\u001b[M" cb cx cy)
          mouse-release (str "\u001b[M" (char (+ 3 32)) cx cy)]
      ;; Mouse press and release
      (send-keys* session mouse-press :pane pane :literal true)
      (send-keys* session mouse-release :pane pane :literal true)

      (when double
        (Thread/sleep 50)
        (send-keys* session mouse-press :pane pane :literal true)
        (send-keys* session mouse-release :pane pane :literal true))

      (println (str "Clicked " click " at (" x ", " y ")" (when double " x2"))))))

(defn cmd-new
  "Create a new tmux session."
  [{:keys [opts]}]
  (let [{:keys [name socket window cmd width height no-session-file force]
         :or   {window "main" width 120 height 40}}                        opts
        socket                                                             (resolve-socket-path socket)]
    (when-not name
      (exit-with-error "new" "session name required"))

    ;; Check if .tmuxb_session already exists and the session is still alive
    (when (and (not no-session-file)
               (not force)
               (fs/exists? ".tmuxb_session"))
      (let [existing (read-session-file)]
        (binding [*socket* (resolve-socket-path (:socket existing))]
          (when (find-session (:session existing))
            (exit-with-error "new" ".tmuxb_session already exists (use --force to overwrite)")))))

    ;; Check if session already exists on this server
    (binding [*socket* socket]
      (when (find-session name)
        (binding [*out* *err*] (println (str "Session '" name "' already exists")))
        (System/exit 1))

      (new-session* name :window window :cmd cmd :width width :height height))

    ;; Write session file unless --no-session-file
    (when-not no-session-file
      (write-session-file name socket))

    (println (str "Created session '" name "'"
                  (when socket (str " (socket: " socket ")"))))))

(defn cmd-kill
  "Kill a tmux session."
  [{:keys [opts]}]
  (let [{:keys [session socket]} opts]
    (when-not session
      (exit-with-error "kill" "session name required"))
    (when-not (find-session session)
      (binding [*out* *err*] (println (str "Session '" session "' not found")))
      (System/exit 1))

    (kill-session* session)

    ;; Delete .tmuxb_session if it matches this session
    (delete-session-file-if-matches session socket)

    (println (str "Killed session '" session "'"))))

(defn cmd-help
  "Show help message."
  [_]
  (let [cmd-by-name (into {} (map (juxt :name identity) commands))
        ordered     (keep cmd-by-name commands-order)
        cmd-entries (for [{:keys [name usage desc]} ordered]
                      (let [args (-> usage
                                     (str/replace #"\[?options\]?" "")
                                     (str/replace #"\s+" " ")
                                     str/trim)]
                        {:cmd        (str name (when (seq args) (str " " args)))
                         :short-desc (first (str/split desc #"\.\s*"))}))
        max-width   (+ 2 (apply max (map #(count (:cmd %)) cmd-entries)))]
    (println "tmuxb - tmux-buddy CLI

A CLI tool that enables humans or LLMs to interact with tmux sessions.

Commands:")
    (doseq [{:keys [cmd short-desc]} cmd-entries]
      (println (format (str "  %-" max-width "s %s") cmd short-desc)))
    (println)
    (println "Use -h or --help with any command for more options.")))

;;; ---------------------------------------------------------------------------
;;; CLI Dispatch
;;; ---------------------------------------------------------------------------

;; Command specifications with help metadata
(def commands-order ["new" "list" "capture" "send" "watch" "windows" "panes" "mouse"])
(def commands
  [{:name       "list"
    :usage      "[options]"
    :desc       "List all tmux sessions."
    :args->opts []
    :coerce     {}
    :spec       {:socket {:alias :S :desc "tmux socket path"}
                 :json   {:coerce :boolean :desc "Output as JSON"}
                 :edn    {:coerce :boolean :desc "Output as EDN"}}}

   {:name       "windows"
    :usage      "SESSION [options]"
    :desc       "List windows in a session."
    :args->opts [:session]
    :coerce     {:session :string}
    :spec       {:socket {:alias :S :desc "tmux socket path"}
                 :json   {:coerce :boolean :desc "Output as JSON"}
                 :edn    {:coerce :boolean :desc "Output as EDN"}}}

   {:name       "panes"
    :usage      "SESSION [options]"
    :desc       "List panes in a session or window."
    :args->opts [:session]
    :coerce     {:session :string}
    :spec       {:socket {:alias :S :desc "tmux socket path"}
                 :window {:alias :w :desc "Window name or index"}
                 :json   {:coerce :boolean :desc "Output as JSON"}
                 :edn    {:coerce :boolean :desc "Output as EDN"}}}

   {:name       "capture"
    :usage      "SESSION [options]"
    :desc       "Capture pane contents. Includes cursor position by default."
    :args->opts [:session]
    :coerce     {:session :string}
    :spec       {:socket     {:alias :S :desc "tmux socket path"}
                 :pane       {:alias :p :desc "Pane ID or index"}
                 :lines      {:alias :n :coerce :long :default 50 :desc "Number of history lines"}
                 :if-changed {:coerce :boolean :desc "Only output if screen changed"}
                 :history    {:alias :H :coerce :boolean :desc "Include scrollback history"}
                 :raw        {:alias :r :coerce :boolean :desc "Raw output without cursor metadata"}
                 :style      {:alias :s :default "none" :desc "Style: none, lines, tags, ansi"}}}

   {:name       "watch"
    :usage      "SESSION [options]"
    :desc       "Watch pane for changes, outputting only when content changes."
    :args->opts [:session]
    :coerce     {:session :string}
    :spec       {:socket   {:alias :S :desc "tmux socket path"}
                 :pane     {:alias :p :desc "Pane ID or index"}
                 :interval {:alias :i :coerce :double :default 0.5 :desc "Poll interval in seconds"}
                 :timeout  {:alias :t :coerce :double :default 30.0 :desc "Max time to watch"}
                 :until    {:alias :u :desc "Stop when this text appears"}}}

   {:name       "send"
    :usage      "SESSION [options] [EDN...] or stdin"
    :desc       "Send keys using EDN DSL. Reads from stdin if no args. See doc/send-keys-dsl.md"
    :args->opts [:session]
    :coerce     {:session :string}
    :spec       {:socket {:alias :S :desc "tmux socket path"}
                 :pane   {:alias :p :desc "Pane ID or index"}
                 :delay  {:alias :d :coerce :long :default 30 :desc "Delay between actions in ms"}}}

   {:name       "mouse"
    :usage      "SESSION X Y [options]"
    :desc       "Send mouse click to pane at x,y coordinates."
    :args->opts [:session :x :y]
    :coerce     {:session :string :x :long :y :long}
    :spec       {:socket {:alias :S :desc "tmux socket path"}
                 :pane   {:alias :p :desc "Pane ID or index"}
                 :click  {:default "left" :desc "Click type: left, right, middle"}
                 :double {:coerce :boolean :desc "Double click"}}}

   {:name       "new"
    :usage      "NAME [options]"
    :desc       "Create a new tmux session."
    :args->opts [:name]
    :coerce     {:name :string}
    :spec       {:socket          {:alias :S :desc "tmux socket path"}
                 :window          {:alias :w :default "main" :desc "Initial window name"}
                 :cmd             {:alias :c :desc "Initial command to run"}
                 :width           {:coerce :long :default 120 :desc "Window width"}
                 :height          {:coerce :long :default 40 :desc "Window height"}
                 :no-session-file {:coerce :boolean :desc "Don't create .tmuxb_session file"}
                 :force           {:alias :f :coerce :boolean :desc "Overwrite existing .tmuxb_session"}}}

   {:name       "kill"
    :usage      "SESSION [options]"
    :desc       "Kill a tmux session."
    :args->opts [:session]
    :coerce     {:session :string}
    :spec       {:socket {:alias :S :desc "tmux socket path"}}}])

(defn get-cmd-spec
  "Get the spec for a command by name."
  [cmd-name]
  (first (filter #(= (:name %) cmd-name) commands)))

(defn add-help-to-spec
  "Add help option to a spec."
  [spec]
  (assoc spec :help {:alias :h :coerce :boolean :desc "Show this help"}))

(defn wrap-with-help
  "Wrap a command function to handle --help."
  [cmd-fn cmd-name]
  (fn [{:keys [opts] :as m}]
    (if (:help opts)
      (let [{:keys [usage desc spec]} (get-cmd-spec cmd-name)]
        (print-cmd-help cmd-name usage desc (add-help-to-spec spec)))
      (cmd-fn m))))

(defn looks-like-edn?
  "Check if string looks like EDN (starts with quote, colon, bracket, etc.)"
  [s]
  (when (string? s)
    (let [trimmed (str/trim s)]
      (or (str/starts-with? trimmed "\"")
          (str/starts-with? trimmed ":")
          (str/starts-with? trimmed "[")
          (str/starts-with? trimmed "{")
          (str/starts-with? trimmed "(")
          (re-matches #"^\d+$" trimmed)))))

(defn wrap-with-session-file
  "Wrap a command function to merge .tmuxb_session defaults into opts.
  CLI opts take precedence over file values. Binds *socket* if provided.

  If the parsed session looks like EDN and we have a default session from
  .tmuxb_session, treats the parsed session as an arg instead."
  [cmd-fn]
  (fn [{:keys [opts args] :as m}]
    (let [defaults       (read-session-file)
          parsed-session (:session opts)
          [session args] (cond
                           (nil? parsed-session)
                           [(:session defaults) args]

                           (and (looks-like-edn? parsed-session)
                                (:session defaults))
                           [(:session defaults) (into [parsed-session] args)]

                           :else
                           [parsed-session args])
          merged         (-> (merge defaults opts)
                             (assoc :session session))
          socket         (:socket merged)]
      (binding [*socket* socket]
        (cmd-fn (assoc m :opts merged :args args))))))

(def dispatch-table
  (into
   [(into {:cmds [] :fn cmd-help})]
   (for [{:keys [name args->opts coerce spec]} commands]
     {:cmds       [name]
      :fn         (wrap-with-help
                   (case name
                     "list"    (wrap-with-session-file cmd-list)
                     "windows" (wrap-with-session-file cmd-windows)
                     "panes"   (wrap-with-session-file cmd-panes)
                     "capture" (wrap-with-session-file cmd-capture)
                     "watch"   (wrap-with-session-file cmd-watch)
                     "send"    (wrap-with-session-file cmd-send)
                     "mouse"   (wrap-with-session-file cmd-mouse)
                     "new"     cmd-new
                     "kill"    (wrap-with-session-file cmd-kill))
                   name)
      :args->opts args->opts
      :coerce     coerce
      :spec       (add-help-to-spec spec)})))

(defn -main [& args]
  (cli/dispatch dispatch-table args))

(when (= *file* (System/getProperty "babashka.file"))
  (apply -main *command-line-args*))
